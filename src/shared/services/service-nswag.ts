//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import { DateTime, Duration } from "luxon";

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AuthService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    authenticate(body: UserLoginInput | undefined): Observable<UserLoginOutput> {
        let url_ = this.baseUrl + "/api/Auth/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserLoginOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserLoginOutput>;
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<UserLoginOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserLoginOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserLoginOutput>(null as any);
    }
}

@Injectable()
export class CategoryService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param searchText (optional) 
     * @param categoryTypeId (optional) 
     * @param parentCategoryId (optional) 
     * @return Success
     */
    getCategoryList(searchText: string | undefined, categoryTypeId: number | undefined, parentCategoryId: number | undefined): Observable<GetAllCategoryInfoListResult> {
        let url_ = this.baseUrl + "/api/Category/GetCategoryList?";
        if (searchText === null)
            throw new Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (categoryTypeId === null)
            throw new Error("The parameter 'categoryTypeId' cannot be null.");
        else if (categoryTypeId !== undefined)
            url_ += "CategoryTypeId=" + encodeURIComponent("" + categoryTypeId) + "&";
        if (parentCategoryId === null)
            throw new Error("The parameter 'parentCategoryId' cannot be null.");
        else if (parentCategoryId !== undefined)
            url_ += "ParentCategoryId=" + encodeURIComponent("" + parentCategoryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCategoryList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCategoryList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAllCategoryInfoListResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAllCategoryInfoListResult>;
        }));
    }

    protected processGetCategoryList(response: HttpResponseBase): Observable<GetAllCategoryInfoListResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAllCategoryInfoListResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAllCategoryInfoListResult>(null as any);
    }

    /**
     * @param categoryId (optional) 
     * @return Success
     */
    getCategoryById(categoryId: number | undefined): Observable<GetAllCategoryInfo> {
        let url_ = this.baseUrl + "/api/Category/GetCategoryById?";
        if (categoryId === null)
            throw new Error("The parameter 'categoryId' cannot be null.");
        else if (categoryId !== undefined)
            url_ += "categoryId=" + encodeURIComponent("" + categoryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCategoryById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCategoryById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAllCategoryInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAllCategoryInfo>;
        }));
    }

    protected processGetCategoryById(response: HttpResponseBase): Observable<GetAllCategoryInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAllCategoryInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAllCategoryInfo>(null as any);
    }

    /**
     * @param searchText (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllCategoryByPage(searchText: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<GetAllCategoryInfoPagedResult> {
        let url_ = this.baseUrl + "/api/Category/GetAllCategoryByPage?";
        if (searchText === null)
            throw new Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCategoryByPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCategoryByPage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAllCategoryInfoPagedResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAllCategoryInfoPagedResult>;
        }));
    }

    protected processGetAllCategoryByPage(response: HttpResponseBase): Observable<GetAllCategoryInfoPagedResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAllCategoryInfoPagedResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAllCategoryInfoPagedResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createCategory(body: CreateCategoryInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Category/CreateCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateCategory(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateCategory(body: UpdateCategoryInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Category/UpdateCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateCategory(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteCategory(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Category/DeleteCategory?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteCategory(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class CategoryTypeService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param searchText (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllCategoryTypeByPage(searchText: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<GetAllCategoryTypeInfoPagedResult> {
        let url_ = this.baseUrl + "/api/CategoryType/GetAllCategoryTypeByPage?";
        if (searchText === null)
            throw new Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCategoryTypeByPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCategoryTypeByPage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAllCategoryTypeInfoPagedResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAllCategoryTypeInfoPagedResult>;
        }));
    }

    protected processGetAllCategoryTypeByPage(response: HttpResponseBase): Observable<GetAllCategoryTypeInfoPagedResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAllCategoryTypeInfoPagedResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAllCategoryTypeInfoPagedResult>(null as any);
    }

    /**
     * @return Success
     */
    getCategoryTypeList(): Observable<GetAllCategoryTypeInfoListResult> {
        let url_ = this.baseUrl + "/api/CategoryType/GetCategoryTypeList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCategoryTypeList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCategoryTypeList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAllCategoryTypeInfoListResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAllCategoryTypeInfoListResult>;
        }));
    }

    protected processGetCategoryTypeList(response: HttpResponseBase): Observable<GetAllCategoryTypeInfoListResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAllCategoryTypeInfoListResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAllCategoryTypeInfoListResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createCategoryType(body: CreateCategoryTypeInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/CategoryType/CreateCategoryType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCategoryType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCategoryType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateCategoryType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateCategoryType(body: UpdateCategoryTypeInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/CategoryType/UpdateCategoryType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCategoryType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCategoryType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateCategoryType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteCategoryType(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/CategoryType/DeleteCategoryType?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCategoryType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCategoryType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteCategoryType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class DocumentService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    uploadDocument(): Observable<void> {
        let url_ = this.baseUrl + "/api/Document/UploadDocument";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadDocument(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadDocument(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUploadDocument(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class EmailService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendEmail(body: EmailTemp | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Email/SendEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class PermissionService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param permissionId (optional) 
     * @return Success
     */
    getPermissionById(permissionId: number | undefined): Observable<GetAllPermissionInfo> {
        let url_ = this.baseUrl + "/api/Permission/GetPermissionById?";
        if (permissionId === null)
            throw new Error("The parameter 'permissionId' cannot be null.");
        else if (permissionId !== undefined)
            url_ += "permissionId=" + encodeURIComponent("" + permissionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPermissionById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPermissionById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAllPermissionInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAllPermissionInfo>;
        }));
    }

    protected processGetPermissionById(response: HttpResponseBase): Observable<GetAllPermissionInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAllPermissionInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAllPermissionInfo>(null as any);
    }

    /**
     * @return Success
     */
    getPermissionList(): Observable<GetAllPermissionInfoListResult> {
        let url_ = this.baseUrl + "/api/Permission/GetPermissionList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPermissionList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPermissionList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAllPermissionInfoListResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAllPermissionInfoListResult>;
        }));
    }

    protected processGetPermissionList(response: HttpResponseBase): Observable<GetAllPermissionInfoListResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAllPermissionInfoListResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAllPermissionInfoListResult>(null as any);
    }

    /**
     * @param searchText (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllPermissionByPage(searchText: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<GetAllPermissionInfoPagedResult> {
        let url_ = this.baseUrl + "/api/Permission/GetAllPermissionByPage?";
        if (searchText === null)
            throw new Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPermissionByPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPermissionByPage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAllPermissionInfoPagedResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAllPermissionInfoPagedResult>;
        }));
    }

    protected processGetAllPermissionByPage(response: HttpResponseBase): Observable<GetAllPermissionInfoPagedResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAllPermissionInfoPagedResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAllPermissionInfoPagedResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createPermission(body: CreatePermissionInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Permission/CreatePermission";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePermission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePermission(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreatePermission(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updatePermission(body: UpdatePermissionInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Permission/UpdatePermission";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePermission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePermission(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdatePermission(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deletePermission(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Permission/DeletePermission?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePermission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePermission(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeletePermission(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class PermissionGroupService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param permissionGroupId (optional) 
     * @return Success
     */
    getPermissionGroupById(permissionGroupId: number | undefined): Observable<GetAllPermissionGroupInfo> {
        let url_ = this.baseUrl + "/api/PermissionGroup/GetPermissionGroupById?";
        if (permissionGroupId === null)
            throw new Error("The parameter 'permissionGroupId' cannot be null.");
        else if (permissionGroupId !== undefined)
            url_ += "permissionGroupId=" + encodeURIComponent("" + permissionGroupId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPermissionGroupById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPermissionGroupById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAllPermissionGroupInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAllPermissionGroupInfo>;
        }));
    }

    protected processGetPermissionGroupById(response: HttpResponseBase): Observable<GetAllPermissionGroupInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAllPermissionGroupInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAllPermissionGroupInfo>(null as any);
    }

    /**
     * @param searchText (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllPermissionGroupByPage(searchText: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<GetAllPermissionGroupInfoPagedResult> {
        let url_ = this.baseUrl + "/api/PermissionGroup/GetAllPermissionGroupByPage?";
        if (searchText === null)
            throw new Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPermissionGroupByPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPermissionGroupByPage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAllPermissionGroupInfoPagedResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAllPermissionGroupInfoPagedResult>;
        }));
    }

    protected processGetAllPermissionGroupByPage(response: HttpResponseBase): Observable<GetAllPermissionGroupInfoPagedResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAllPermissionGroupInfoPagedResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAllPermissionGroupInfoPagedResult>(null as any);
    }

    /**
     * @return Success
     */
    getPermissionGroupList(): Observable<GetAllPermissionGroupInfoListResult> {
        let url_ = this.baseUrl + "/api/PermissionGroup/GetPermissionGroupList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPermissionGroupList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPermissionGroupList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAllPermissionGroupInfoListResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAllPermissionGroupInfoListResult>;
        }));
    }

    protected processGetPermissionGroupList(response: HttpResponseBase): Observable<GetAllPermissionGroupInfoListResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAllPermissionGroupInfoListResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAllPermissionGroupInfoListResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createPermissionGroup(body: CreatePermissionGroupInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/PermissionGroup/CreatePermissionGroup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePermissionGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePermissionGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreatePermissionGroup(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updatePermissionGroup(body: UpdatePermissionGroupInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/PermissionGroup/UpdatePermissionGroup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePermissionGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePermissionGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdatePermissionGroup(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param permissionGroupId (optional) 
     * @return Success
     */
    deletePermissionGroup(permissionGroupId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/PermissionGroup/DeletePermissionGroup?";
        if (permissionGroupId === null)
            throw new Error("The parameter 'permissionGroupId' cannot be null.");
        else if (permissionGroupId !== undefined)
            url_ += "permissionGroupId=" + encodeURIComponent("" + permissionGroupId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePermissionGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePermissionGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeletePermissionGroup(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class UserService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getUserById(userId: number | undefined): Observable<GetAllUserInfo> {
        let url_ = this.baseUrl + "/api/User/GetUserById?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAllUserInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAllUserInfo>;
        }));
    }

    protected processGetUserById(response: HttpResponseBase): Observable<GetAllUserInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAllUserInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAllUserInfo>(null as any);
    }

    /**
     * @return Success
     */
    getUserList(): Observable<GetAllUserInfoListResult> {
        let url_ = this.baseUrl + "/api/User/GetUserList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAllUserInfoListResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAllUserInfoListResult>;
        }));
    }

    protected processGetUserList(response: HttpResponseBase): Observable<GetAllUserInfoListResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAllUserInfoListResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAllUserInfoListResult>(null as any);
    }

    /**
     * @param searchText (optional) 
     * @param isActive (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllUsersByPage(searchText: string | undefined, isActive: UserStatusEnum | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<GetAllUserInfoPagedResult> {
        let url_ = this.baseUrl + "/api/User/GetAllUsersByPage?";
        if (searchText === null)
            throw new Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUsersByPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUsersByPage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAllUserInfoPagedResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAllUserInfoPagedResult>;
        }));
    }

    protected processGetAllUsersByPage(response: HttpResponseBase): Observable<GetAllUserInfoPagedResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAllUserInfoPagedResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAllUserInfoPagedResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createUser(body: CreateUserInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/User/CreateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateUser(body: UpdateUserInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/User/UpdateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteUser(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/User/DeleteUser?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class UserCategoryService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getCategoryTypeAndCategoryList(userId: number | undefined): Observable<CategoryAndUserInfoListResult> {
        let url_ = this.baseUrl + "/api/UserCategory/GetCategoryTypeAndCategoryList?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCategoryTypeAndCategoryList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCategoryTypeAndCategoryList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryAndUserInfoListResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryAndUserInfoListResult>;
        }));
    }

    protected processGetCategoryTypeAndCategoryList(response: HttpResponseBase): Observable<CategoryAndUserInfoListResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryAndUserInfoListResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CategoryAndUserInfoListResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateUserCategory(body: CreateOrUpdateUserCategoryInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/UserCategory/CreateOrUpdateUserCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateUserCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateUserCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrUpdateUserCategory(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class UserDocumentService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param searchText (optional) 
     * @param categoryId (optional) 
     * @param userId (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllUserDocumentByPage(searchText: string | undefined, categoryId: number | undefined, userId: number | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<GetAllUserDocumentInfoPagedResult> {
        let url_ = this.baseUrl + "/api/UserDocument/GetAllUserDocumentByPage?";
        if (searchText === null)
            throw new Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (categoryId === null)
            throw new Error("The parameter 'categoryId' cannot be null.");
        else if (categoryId !== undefined)
            url_ += "CategoryId=" + encodeURIComponent("" + categoryId) + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserDocumentByPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserDocumentByPage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAllUserDocumentInfoPagedResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAllUserDocumentInfoPagedResult>;
        }));
    }

    protected processGetAllUserDocumentByPage(response: HttpResponseBase): Observable<GetAllUserDocumentInfoPagedResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAllUserDocumentInfoPagedResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAllUserDocumentInfoPagedResult>(null as any);
    }

    /**
     * @param userDocumentId (optional) 
     * @return Success
     */
    getUserDocumentById(userDocumentId: number | undefined): Observable<GetAllUserDocumentInfo> {
        let url_ = this.baseUrl + "/api/UserDocument/GetUserDocumentById?";
        if (userDocumentId === null)
            throw new Error("The parameter 'userDocumentId' cannot be null.");
        else if (userDocumentId !== undefined)
            url_ += "userDocumentId=" + encodeURIComponent("" + userDocumentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserDocumentById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserDocumentById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAllUserDocumentInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAllUserDocumentInfo>;
        }));
    }

    protected processGetUserDocumentById(response: HttpResponseBase): Observable<GetAllUserDocumentInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAllUserDocumentInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAllUserDocumentInfo>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createUserDocument(body: CreateUserDocumentInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/UserDocument/CreateUserDocument";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUserDocument(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUserDocument(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateUserDocument(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateUserDocument(body: UpdateUserDocumentInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/UserDocument/UpdateUserDocument";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserDocument(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserDocument(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateUserDocument(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param userDocumentId (optional) 
     * @return Success
     */
    deleteUserDocument(userDocumentId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/UserDocument/DeleteUserDocument?";
        if (userDocumentId === null)
            throw new Error("The parameter 'userDocumentId' cannot be null.");
        else if (userDocumentId !== undefined)
            url_ += "userDocumentId=" + encodeURIComponent("" + userDocumentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUserDocument(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUserDocument(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteUserDocument(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class UserPermissionService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getPermissionGroupAndPermission(userId: number | undefined): Observable<GetPermissionGroupAndPermissionListListResult> {
        let url_ = this.baseUrl + "/api/UserPermission/GetPermissionGroupAndPermission?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPermissionGroupAndPermission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPermissionGroupAndPermission(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPermissionGroupAndPermissionListListResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPermissionGroupAndPermissionListListResult>;
        }));
    }

    protected processGetPermissionGroupAndPermission(response: HttpResponseBase): Observable<GetPermissionGroupAndPermissionListListResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetPermissionGroupAndPermissionListListResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPermissionGroupAndPermissionListListResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateUserPermission(body: CreateOrUpdateUserPermissionInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/UserPermission/CreateOrUpdateUserPermission";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateUserPermission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateUserPermission(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrUpdateUserPermission(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

export class CategoryAndUserInfo implements ICategoryAndUserInfo {
    categoryId!: number;
    parentCategoryId!: number;
    categoryName!: string | undefined;
    isChecked!: boolean;

    constructor(data?: ICategoryAndUserInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.categoryId = _data["categoryId"];
            this.parentCategoryId = _data["parentCategoryId"];
            this.categoryName = _data["categoryName"];
            this.isChecked = _data["isChecked"];
        }
    }

    static fromJS(data: any): CategoryAndUserInfo {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryAndUserInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryId"] = this.categoryId;
        data["parentCategoryId"] = this.parentCategoryId;
        data["categoryName"] = this.categoryName;
        data["isChecked"] = this.isChecked;
        return data;
    }
}

export interface ICategoryAndUserInfo {
    categoryId: number;
    parentCategoryId: number;
    categoryName: string | undefined;
    isChecked: boolean;
}

export class CategoryAndUserInfoListResult implements ICategoryAndUserInfoListResult {
    items!: CategoryAndUserInfo[] | undefined;

    constructor(data?: ICategoryAndUserInfoListResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CategoryAndUserInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CategoryAndUserInfoListResult {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryAndUserInfoListResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICategoryAndUserInfoListResult {
    items: CategoryAndUserInfo[] | undefined;
}

export class CreateCategoryInput implements ICreateCategoryInput {
    name!: string | undefined;
    categoryTypeId!: number;
    parentCategoryId!: number;

    constructor(data?: ICreateCategoryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.categoryTypeId = _data["categoryTypeId"];
            this.parentCategoryId = _data["parentCategoryId"];
        }
    }

    static fromJS(data: any): CreateCategoryInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCategoryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["categoryTypeId"] = this.categoryTypeId;
        data["parentCategoryId"] = this.parentCategoryId;
        return data;
    }
}

export interface ICreateCategoryInput {
    name: string | undefined;
    categoryTypeId: number;
    parentCategoryId: number;
}

export class CreateCategoryTypeInput implements ICreateCategoryTypeInput {
    name!: string | undefined;

    constructor(data?: ICreateCategoryTypeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateCategoryTypeInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCategoryTypeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface ICreateCategoryTypeInput {
    name: string | undefined;
}

export class CreateOrUpdateUserCategoryInput implements ICreateOrUpdateUserCategoryInput {
    userId!: number;
    categoryList!: CreateUserCategoryInput[] | undefined;

    constructor(data?: ICreateOrUpdateUserCategoryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            if (Array.isArray(_data["categoryList"])) {
                this.categoryList = [] as any;
                for (let item of _data["categoryList"])
                    this.categoryList!.push(CreateUserCategoryInput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateOrUpdateUserCategoryInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateUserCategoryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        if (Array.isArray(this.categoryList)) {
            data["categoryList"] = [];
            for (let item of this.categoryList)
                data["categoryList"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateOrUpdateUserCategoryInput {
    userId: number;
    categoryList: CreateUserCategoryInput[] | undefined;
}

export class CreateOrUpdateUserPermissionInput implements ICreateOrUpdateUserPermissionInput {
    userId!: number;
    permissionList!: CreateUserPermissionInput[] | undefined;

    constructor(data?: ICreateOrUpdateUserPermissionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            if (Array.isArray(_data["permissionList"])) {
                this.permissionList = [] as any;
                for (let item of _data["permissionList"])
                    this.permissionList!.push(CreateUserPermissionInput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateOrUpdateUserPermissionInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateUserPermissionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        if (Array.isArray(this.permissionList)) {
            data["permissionList"] = [];
            for (let item of this.permissionList)
                data["permissionList"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateOrUpdateUserPermissionInput {
    userId: number;
    permissionList: CreateUserPermissionInput[] | undefined;
}

export class CreatePermissionGroupInput implements ICreatePermissionGroupInput {
    name!: string | undefined;
    description!: string | undefined;

    constructor(data?: ICreatePermissionGroupInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CreatePermissionGroupInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePermissionGroupInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        return data;
    }
}

export interface ICreatePermissionGroupInput {
    name: string | undefined;
    description: string | undefined;
}

export class CreatePermissionInput implements ICreatePermissionInput {
    name!: string | undefined;
    description!: string | undefined;
    permissionGroupId!: number;

    constructor(data?: ICreatePermissionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.permissionGroupId = _data["permissionGroupId"];
        }
    }

    static fromJS(data: any): CreatePermissionInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePermissionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["permissionGroupId"] = this.permissionGroupId;
        return data;
    }
}

export interface ICreatePermissionInput {
    name: string | undefined;
    description: string | undefined;
    permissionGroupId: number;
}

export class CreateUserCategoryInput implements ICreateUserCategoryInput {
    categoryId!: number;

    constructor(data?: ICreateUserCategoryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.categoryId = _data["categoryId"];
        }
    }

    static fromJS(data: any): CreateUserCategoryInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserCategoryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryId"] = this.categoryId;
        return data;
    }
}

export interface ICreateUserCategoryInput {
    categoryId: number;
}

export class CreateUserDocumentInput implements ICreateUserDocumentInput {
    documentId!: number;
    documentTitle!: string | undefined;
    categoryId!: number;
    userId!: number;

    constructor(data?: ICreateUserDocumentInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.documentId = _data["documentId"];
            this.documentTitle = _data["documentTitle"];
            this.categoryId = _data["categoryId"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): CreateUserDocumentInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserDocumentInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentId"] = this.documentId;
        data["documentTitle"] = this.documentTitle;
        data["categoryId"] = this.categoryId;
        data["userId"] = this.userId;
        return data;
    }
}

export interface ICreateUserDocumentInput {
    documentId: number;
    documentTitle: string | undefined;
    categoryId: number;
    userId: number;
}

export class CreateUserInput implements ICreateUserInput {
    name!: string | undefined;
    surname!: string | undefined;
    userName!: string | undefined;
    email!: string | undefined;
    birthDate!: DateTime;

    constructor(data?: ICreateUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.email = _data["email"];
            this.birthDate = _data["birthDate"] ? DateTime.fromISO(_data["birthDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["birthDate"] = this.birthDate ? this.birthDate.toString() : <any>undefined;
        return data;
    }
}

export interface ICreateUserInput {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    email: string | undefined;
    birthDate: DateTime;
}

export class CreateUserPermissionInput implements ICreateUserPermissionInput {
    permissionId!: number;

    constructor(data?: ICreateUserPermissionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.permissionId = _data["permissionId"];
        }
    }

    static fromJS(data: any): CreateUserPermissionInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserPermissionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["permissionId"] = this.permissionId;
        return data;
    }
}

export interface ICreateUserPermissionInput {
    permissionId: number;
}

export class DocumentCategoryInfo implements IDocumentCategoryInfo {
    categoryId!: number;
    name!: string | undefined;

    constructor(data?: IDocumentCategoryInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.categoryId = _data["categoryId"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): DocumentCategoryInfo {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentCategoryInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryId"] = this.categoryId;
        data["name"] = this.name;
        return data;
    }
}

export interface IDocumentCategoryInfo {
    categoryId: number;
    name: string | undefined;
}

export class DocumentCategoryTypeInfo implements IDocumentCategoryTypeInfo {
    categoryTpyeId!: number;
    name!: string | undefined;

    constructor(data?: IDocumentCategoryTypeInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.categoryTpyeId = _data["categoryTpyeId"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): DocumentCategoryTypeInfo {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentCategoryTypeInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryTpyeId"] = this.categoryTpyeId;
        data["name"] = this.name;
        return data;
    }
}

export interface IDocumentCategoryTypeInfo {
    categoryTpyeId: number;
    name: string | undefined;
}

export class DocumentInfo implements IDocumentInfo {
    id!: number;
    name!: string | undefined;
    contentType!: string | undefined;

    constructor(data?: IDocumentInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.contentType = _data["contentType"];
        }
    }

    static fromJS(data: any): DocumentInfo {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["contentType"] = this.contentType;
        return data;
    }
}

export interface IDocumentInfo {
    id: number;
    name: string | undefined;
    contentType: string | undefined;
}

export class DocumentUserInfo implements IDocumentUserInfo {
    userId!: number;
    name!: string | undefined;
    surname!: string | undefined;
    readonly fullName!: string | undefined;

    constructor(data?: IDocumentUserInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            (<any>this).fullName = _data["fullName"];
        }
    }

    static fromJS(data: any): DocumentUserInfo {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentUserInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["fullName"] = this.fullName;
        return data;
    }
}

export interface IDocumentUserInfo {
    userId: number;
    name: string | undefined;
    surname: string | undefined;
    fullName: string | undefined;
}

export class EmailTemp implements IEmailTemp {
    to!: string | undefined;
    subject!: string | undefined;
    body!: string | undefined;

    constructor(data?: IEmailTemp) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.to = _data["to"];
            this.subject = _data["subject"];
            this.body = _data["body"];
        }
    }

    static fromJS(data: any): EmailTemp {
        data = typeof data === 'object' ? data : {};
        let result = new EmailTemp();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["to"] = this.to;
        data["subject"] = this.subject;
        data["body"] = this.body;
        return data;
    }
}

export interface IEmailTemp {
    to: string | undefined;
    subject: string | undefined;
    body: string | undefined;
}

export class GetAllCategoryInfo implements IGetAllCategoryInfo {
    id!: number;
    name!: string | undefined;
    parentCategoryId!: number;
    categoryTypeId!: number;
    categoryTypeName!: string | undefined;

    constructor(data?: IGetAllCategoryInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.parentCategoryId = _data["parentCategoryId"];
            this.categoryTypeId = _data["categoryTypeId"];
            this.categoryTypeName = _data["categoryTypeName"];
        }
    }

    static fromJS(data: any): GetAllCategoryInfo {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllCategoryInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["parentCategoryId"] = this.parentCategoryId;
        data["categoryTypeId"] = this.categoryTypeId;
        data["categoryTypeName"] = this.categoryTypeName;
        return data;
    }
}

export interface IGetAllCategoryInfo {
    id: number;
    name: string | undefined;
    parentCategoryId: number;
    categoryTypeId: number;
    categoryTypeName: string | undefined;
}

export class GetAllCategoryInfoListResult implements IGetAllCategoryInfoListResult {
    items!: GetAllCategoryInfo[] | undefined;

    constructor(data?: IGetAllCategoryInfoListResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAllCategoryInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetAllCategoryInfoListResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllCategoryInfoListResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetAllCategoryInfoListResult {
    items: GetAllCategoryInfo[] | undefined;
}

export class GetAllCategoryInfoPagedResult implements IGetAllCategoryInfoPagedResult {
    items!: GetAllCategoryInfo[] | undefined;
    totalCount!: number;

    constructor(data?: IGetAllCategoryInfoPagedResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAllCategoryInfo.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): GetAllCategoryInfoPagedResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllCategoryInfoPagedResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IGetAllCategoryInfoPagedResult {
    items: GetAllCategoryInfo[] | undefined;
    totalCount: number;
}

export class GetAllCategoryTypeInfo implements IGetAllCategoryTypeInfo {
    id!: number;
    name!: string | undefined;

    constructor(data?: IGetAllCategoryTypeInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): GetAllCategoryTypeInfo {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllCategoryTypeInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IGetAllCategoryTypeInfo {
    id: number;
    name: string | undefined;
}

export class GetAllCategoryTypeInfoListResult implements IGetAllCategoryTypeInfoListResult {
    items!: GetAllCategoryTypeInfo[] | undefined;

    constructor(data?: IGetAllCategoryTypeInfoListResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAllCategoryTypeInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetAllCategoryTypeInfoListResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllCategoryTypeInfoListResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetAllCategoryTypeInfoListResult {
    items: GetAllCategoryTypeInfo[] | undefined;
}

export class GetAllCategoryTypeInfoPagedResult implements IGetAllCategoryTypeInfoPagedResult {
    items!: GetAllCategoryTypeInfo[] | undefined;
    totalCount!: number;

    constructor(data?: IGetAllCategoryTypeInfoPagedResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAllCategoryTypeInfo.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): GetAllCategoryTypeInfoPagedResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllCategoryTypeInfoPagedResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IGetAllCategoryTypeInfoPagedResult {
    items: GetAllCategoryTypeInfo[] | undefined;
    totalCount: number;
}

export class GetAllPermissionGroupInfo implements IGetAllPermissionGroupInfo {
    id!: number;
    name!: string | undefined;
    description!: string | undefined;

    constructor(data?: IGetAllPermissionGroupInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): GetAllPermissionGroupInfo {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllPermissionGroupInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        return data;
    }
}

export interface IGetAllPermissionGroupInfo {
    id: number;
    name: string | undefined;
    description: string | undefined;
}

export class GetAllPermissionGroupInfoListResult implements IGetAllPermissionGroupInfoListResult {
    items!: GetAllPermissionGroupInfo[] | undefined;

    constructor(data?: IGetAllPermissionGroupInfoListResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAllPermissionGroupInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetAllPermissionGroupInfoListResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllPermissionGroupInfoListResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetAllPermissionGroupInfoListResult {
    items: GetAllPermissionGroupInfo[] | undefined;
}

export class GetAllPermissionGroupInfoPagedResult implements IGetAllPermissionGroupInfoPagedResult {
    items!: GetAllPermissionGroupInfo[] | undefined;
    totalCount!: number;

    constructor(data?: IGetAllPermissionGroupInfoPagedResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAllPermissionGroupInfo.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): GetAllPermissionGroupInfoPagedResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllPermissionGroupInfoPagedResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IGetAllPermissionGroupInfoPagedResult {
    items: GetAllPermissionGroupInfo[] | undefined;
    totalCount: number;
}

export class GetAllPermissionInfo implements IGetAllPermissionInfo {
    id!: number;
    name!: string | undefined;
    description!: string | undefined;
    permissionGroupId!: number;
    permissionGroupName!: string | undefined;

    constructor(data?: IGetAllPermissionInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.permissionGroupId = _data["permissionGroupId"];
            this.permissionGroupName = _data["permissionGroupName"];
        }
    }

    static fromJS(data: any): GetAllPermissionInfo {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllPermissionInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["permissionGroupId"] = this.permissionGroupId;
        data["permissionGroupName"] = this.permissionGroupName;
        return data;
    }
}

export interface IGetAllPermissionInfo {
    id: number;
    name: string | undefined;
    description: string | undefined;
    permissionGroupId: number;
    permissionGroupName: string | undefined;
}

export class GetAllPermissionInfoListResult implements IGetAllPermissionInfoListResult {
    items!: GetAllPermissionInfo[] | undefined;

    constructor(data?: IGetAllPermissionInfoListResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAllPermissionInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetAllPermissionInfoListResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllPermissionInfoListResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetAllPermissionInfoListResult {
    items: GetAllPermissionInfo[] | undefined;
}

export class GetAllPermissionInfoPagedResult implements IGetAllPermissionInfoPagedResult {
    items!: GetAllPermissionInfo[] | undefined;
    totalCount!: number;

    constructor(data?: IGetAllPermissionInfoPagedResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAllPermissionInfo.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): GetAllPermissionInfoPagedResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllPermissionInfoPagedResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IGetAllPermissionInfoPagedResult {
    items: GetAllPermissionInfo[] | undefined;
    totalCount: number;
}

export class GetAllUserDocumentInfo implements IGetAllUserDocumentInfo {
    documentUser!: DocumentUserInfo;
    documentCategory!: DocumentCategoryInfo;
    documentCategoryType!: DocumentCategoryTypeInfo;
    documentInfo!: DocumentInfo;
    userDocumentId!: number;
    documentTitle!: string | undefined;
    creationTime!: DateTime;

    constructor(data?: IGetAllUserDocumentInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.documentUser = _data["documentUser"] ? DocumentUserInfo.fromJS(_data["documentUser"]) : <any>undefined;
            this.documentCategory = _data["documentCategory"] ? DocumentCategoryInfo.fromJS(_data["documentCategory"]) : <any>undefined;
            this.documentCategoryType = _data["documentCategoryType"] ? DocumentCategoryTypeInfo.fromJS(_data["documentCategoryType"]) : <any>undefined;
            this.documentInfo = _data["documentInfo"] ? DocumentInfo.fromJS(_data["documentInfo"]) : <any>undefined;
            this.userDocumentId = _data["userDocumentId"];
            this.documentTitle = _data["documentTitle"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAllUserDocumentInfo {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllUserDocumentInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentUser"] = this.documentUser ? this.documentUser.toJSON() : <any>undefined;
        data["documentCategory"] = this.documentCategory ? this.documentCategory.toJSON() : <any>undefined;
        data["documentCategoryType"] = this.documentCategoryType ? this.documentCategoryType.toJSON() : <any>undefined;
        data["documentInfo"] = this.documentInfo ? this.documentInfo.toJSON() : <any>undefined;
        data["userDocumentId"] = this.userDocumentId;
        data["documentTitle"] = this.documentTitle;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        return data;
    }
}

export interface IGetAllUserDocumentInfo {
    documentUser: DocumentUserInfo;
    documentCategory: DocumentCategoryInfo;
    documentCategoryType: DocumentCategoryTypeInfo;
    documentInfo: DocumentInfo;
    userDocumentId: number;
    documentTitle: string | undefined;
    creationTime: DateTime;
}

export class GetAllUserDocumentInfoPagedResult implements IGetAllUserDocumentInfoPagedResult {
    items!: GetAllUserDocumentInfo[] | undefined;
    totalCount!: number;

    constructor(data?: IGetAllUserDocumentInfoPagedResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAllUserDocumentInfo.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): GetAllUserDocumentInfoPagedResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllUserDocumentInfoPagedResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IGetAllUserDocumentInfoPagedResult {
    items: GetAllUserDocumentInfo[] | undefined;
    totalCount: number;
}

export class GetAllUserInfo implements IGetAllUserInfo {
    id!: number;
    name!: string | undefined;
    surname!: string | undefined;
    userName!: string | undefined;
    email!: string | undefined;
    birthDate!: DateTime;

    constructor(data?: IGetAllUserInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.email = _data["email"];
            this.birthDate = _data["birthDate"] ? DateTime.fromISO(_data["birthDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAllUserInfo {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllUserInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["birthDate"] = this.birthDate ? this.birthDate.toString() : <any>undefined;
        return data;
    }
}

export interface IGetAllUserInfo {
    id: number;
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    email: string | undefined;
    birthDate: DateTime;
}

export class GetAllUserInfoListResult implements IGetAllUserInfoListResult {
    items!: GetAllUserInfo[] | undefined;

    constructor(data?: IGetAllUserInfoListResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAllUserInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetAllUserInfoListResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllUserInfoListResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetAllUserInfoListResult {
    items: GetAllUserInfo[] | undefined;
}

export class GetAllUserInfoPagedResult implements IGetAllUserInfoPagedResult {
    items!: GetAllUserInfo[] | undefined;
    totalCount!: number;

    constructor(data?: IGetAllUserInfoPagedResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAllUserInfo.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): GetAllUserInfoPagedResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllUserInfoPagedResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IGetAllUserInfoPagedResult {
    items: GetAllUserInfo[] | undefined;
    totalCount: number;
}

export class GetPermissionGroupAndPermissionList implements IGetPermissionGroupAndPermissionList {
    permissionGroupId!: number;
    permissionGroupName!: string | undefined;
    permissionList!: PermissionAndUserInfo[] | undefined;

    constructor(data?: IGetPermissionGroupAndPermissionList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.permissionGroupId = _data["permissionGroupId"];
            this.permissionGroupName = _data["permissionGroupName"];
            if (Array.isArray(_data["permissionList"])) {
                this.permissionList = [] as any;
                for (let item of _data["permissionList"])
                    this.permissionList!.push(PermissionAndUserInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetPermissionGroupAndPermissionList {
        data = typeof data === 'object' ? data : {};
        let result = new GetPermissionGroupAndPermissionList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["permissionGroupId"] = this.permissionGroupId;
        data["permissionGroupName"] = this.permissionGroupName;
        if (Array.isArray(this.permissionList)) {
            data["permissionList"] = [];
            for (let item of this.permissionList)
                data["permissionList"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetPermissionGroupAndPermissionList {
    permissionGroupId: number;
    permissionGroupName: string | undefined;
    permissionList: PermissionAndUserInfo[] | undefined;
}

export class GetPermissionGroupAndPermissionListListResult implements IGetPermissionGroupAndPermissionListListResult {
    items!: GetPermissionGroupAndPermissionList[] | undefined;

    constructor(data?: IGetPermissionGroupAndPermissionListListResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetPermissionGroupAndPermissionList.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetPermissionGroupAndPermissionListListResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetPermissionGroupAndPermissionListListResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetPermissionGroupAndPermissionListListResult {
    items: GetPermissionGroupAndPermissionList[] | undefined;
}

export class PermissionAndUserInfo implements IPermissionAndUserInfo {
    permissionId!: number;
    permissionName!: string | undefined;
    isChecked!: boolean;

    constructor(data?: IPermissionAndUserInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.permissionId = _data["permissionId"];
            this.permissionName = _data["permissionName"];
            this.isChecked = _data["isChecked"];
        }
    }

    static fromJS(data: any): PermissionAndUserInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionAndUserInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["permissionId"] = this.permissionId;
        data["permissionName"] = this.permissionName;
        data["isChecked"] = this.isChecked;
        return data;
    }
}

export interface IPermissionAndUserInfo {
    permissionId: number;
    permissionName: string | undefined;
    isChecked: boolean;
}

export class UpdateCategoryInput implements IUpdateCategoryInput {
    id!: number;
    name!: string | undefined;
    categoryTypeId!: number;
    parentCategoryId!: number;

    constructor(data?: IUpdateCategoryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.categoryTypeId = _data["categoryTypeId"];
            this.parentCategoryId = _data["parentCategoryId"];
        }
    }

    static fromJS(data: any): UpdateCategoryInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCategoryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["categoryTypeId"] = this.categoryTypeId;
        data["parentCategoryId"] = this.parentCategoryId;
        return data;
    }
}

export interface IUpdateCategoryInput {
    id: number;
    name: string | undefined;
    categoryTypeId: number;
    parentCategoryId: number;
}

export class UpdateCategoryTypeInput implements IUpdateCategoryTypeInput {
    id!: number;
    name!: string | undefined;

    constructor(data?: IUpdateCategoryTypeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): UpdateCategoryTypeInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCategoryTypeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IUpdateCategoryTypeInput {
    id: number;
    name: string | undefined;
}

export class UpdatePermissionGroupInput implements IUpdatePermissionGroupInput {
    id!: number;
    name!: string | undefined;
    description!: string | undefined;

    constructor(data?: IUpdatePermissionGroupInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): UpdatePermissionGroupInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePermissionGroupInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        return data;
    }
}

export interface IUpdatePermissionGroupInput {
    id: number;
    name: string | undefined;
    description: string | undefined;
}

export class UpdatePermissionInput implements IUpdatePermissionInput {
    id!: number;
    name!: string | undefined;
    description!: string | undefined;
    permissionGroupId!: number;

    constructor(data?: IUpdatePermissionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.permissionGroupId = _data["permissionGroupId"];
        }
    }

    static fromJS(data: any): UpdatePermissionInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePermissionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["permissionGroupId"] = this.permissionGroupId;
        return data;
    }
}

export interface IUpdatePermissionInput {
    id: number;
    name: string | undefined;
    description: string | undefined;
    permissionGroupId: number;
}

export class UpdateUserDocumentInput implements IUpdateUserDocumentInput {
    userDocumentId!: number;
    documentId!: number;
    documentTitle!: string | undefined;
    categoryId!: number;
    userId!: number;

    constructor(data?: IUpdateUserDocumentInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userDocumentId = _data["userDocumentId"];
            this.documentId = _data["documentId"];
            this.documentTitle = _data["documentTitle"];
            this.categoryId = _data["categoryId"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): UpdateUserDocumentInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserDocumentInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userDocumentId"] = this.userDocumentId;
        data["documentId"] = this.documentId;
        data["documentTitle"] = this.documentTitle;
        data["categoryId"] = this.categoryId;
        data["userId"] = this.userId;
        return data;
    }
}

export interface IUpdateUserDocumentInput {
    userDocumentId: number;
    documentId: number;
    documentTitle: string | undefined;
    categoryId: number;
    userId: number;
}

export class UpdateUserInput implements IUpdateUserInput {
    id!: number;
    name!: string | undefined;
    surname!: string | undefined;
    userName!: string | undefined;
    email!: string | undefined;
    birthDate!: DateTime;
    isActive!: boolean;

    constructor(data?: IUpdateUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.email = _data["email"];
            this.birthDate = _data["birthDate"] ? DateTime.fromISO(_data["birthDate"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpdateUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["birthDate"] = this.birthDate ? this.birthDate.toString() : <any>undefined;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IUpdateUserInput {
    id: number;
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    email: string | undefined;
    birthDate: DateTime;
    isActive: boolean;
}

export class UserLoginInput implements IUserLoginInput {
    email!: string | undefined;
    password!: string | undefined;

    constructor(data?: IUserLoginInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): UserLoginInput {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface IUserLoginInput {
    email: string | undefined;
    password: string | undefined;
}

export class UserLoginOutput implements IUserLoginOutput {
    id!: number;
    name!: string | undefined;
    surname!: string | undefined;
    userName!: string | undefined;
    email!: string | undefined;
    token!: string | undefined;

    constructor(data?: IUserLoginOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.email = _data["email"];
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): UserLoginOutput {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["token"] = this.token;
        return data;
    }
}

export interface IUserLoginOutput {
    id: number;
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    email: string | undefined;
    token: string | undefined;
}

export enum UserStatusEnum {
    _1 = 1,
    _2 = 2,
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}

C:\Users\emre_\source\DigitalArchiveClient\nswag\service.extensions.ts